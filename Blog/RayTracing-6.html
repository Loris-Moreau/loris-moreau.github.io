<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RayTracing 6</title>
    <link rel="icon" type="image/x-icon" href="../Images/Suprise.webp">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Loris Moreau">
    <meta name="description" content="Raytracing Blog">
    <meta name="keywords" content="Showcase, Loris, Moreau, Loris Moreau, Programmer, coding adventure, Blog, Post, Raytracing, C++, CPP, Raytracing in one weekend, Diffuse, Materials, Shaders">

    <!-- Styles -->
    <link rel="stylesheet" href="../Styles/style.css">
    <link rel="stylesheet" href="../Styles/Code-Quote.css">

    <script src="../Scripts/Carousel.js" defer></script>

    <style>
        /* Small local style for quote */
        .quote {
            background: var(--code-title-bg-color);
            padding: 0.1em 0.6em;
            margin: 0 0.2em;
            border-radius: 0.4em;
            font-size: 0.95rem;
            color: var(--text-color-bright);
        }
    </style>
</head>

<body>
<!-- Main of the post -->
<main id="BlogPost" class="post">
    <!-- Top showcase: carousel + short intro in a flex row -->
    <header>
        <!-- ========== Section 1 Navbar ========== -->
        <nav style="margin: 0 auto 2em auto;">
            <ul>
                <li><a href="../Blog.html">Back</a></li>
                <li><a href="../index.html" target="_blank">Main</a></li>
                <li><a href="../Blog.html" target="_blank">Blog</a></li>
                <li><a href="../Resources.html" target="_blank">Resources</a></li>
            </ul>
        </nav>

        <div class="flex-container">
            <div class="showcase-carousel" role="region" aria-label="Showcase carousel">
                <button class="carousel-button prev" aria-label="Previous slide">&larr;</button>
                <div class="carousel-viewport">
                    <div class="carousel-track">
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/RayTracing/DiffuseMatRender.webp" alt="Diffuse Material Render">
                        </div>
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/RayTracing/LambertianReflection.webp" alt="Lambertian Illustration">
                        </div>
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/Suprise.webp" alt="Suprise">
                        </div>
                    </div>
                </div>
                <button class="carousel-button next" aria-label="Next slide">&rarr;</button>
                <div class="carousel-dots" aria-hidden="false"></div>
            </div>

            <!-- Intro / author column -->
            <div class="text-container">
                <h1>Raytracing in one weekend in C++ â€” Part 6</h1>
                <p>Diffuse materials, sampling, Lambertian reflection and gamma correction.</p>
                <p><a target="_blank" href="https://github.com/Loris-Moreau/RayTracing" class="cta-button">GitHub Repository</a></p>
            </div>
        </div>
    </header>

    <!-- Section: Intro -->
    <section>
        <div>
            <h2 class="underline" style="text-decoration-color: dodgerblue">Diffuse Material</h2>
            <h4>Colors !!!!</h4>

            <p>A diffuse surface scatters incoming rays in random directions and attenuates light according to its color.</p>

            <figure>
                <img loading="lazy" src="../Images/RayTracing/Diffuse_reflection.webp" alt="Diffuse Reflection" style="width:32%; padding-bottom:5px" />
                <figcaption><a href="https://en.m.wikipedia.org/wiki/File:Diffuse_reflection.svg" target="_blank">img. Source</a></figcaption>
            </figure>
        </div>
    </section>

    <!-- Section: Vector utilities -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Vector utilities & random sampling</h2>

        <p>Utilities to pick random directions inside a unit sphere / on a hemisphere.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Vector3.h</p></div>
                <div class="Sconsole">
<pre><code>   double SquaredLength() const
   {
       return x * x + y * y + z * z;
   }

   static Vector3 Random()
   {
       return Vector3(RandomDouble(), RandomDouble(), RandomDouble());
   }

   static Vector3 Random(double min, double max)
   {
       return Vector3(RandomDouble(min, max), RandomDouble(min, max), RandomDouble(min, max));
   }
};

...

inline Vector3 Unit(const Vector3& vector)
{
   return vector / vector.Length();
}

inline Position RandomInUnitSphere()
{
   while(true)
   {
       Position position = Vector3::Random(-1, 1);
       if(position.SquaredLength() &lt 1) return position;
   }
}

inline Vector3 RandomUnitVector()
{
   return Unit(RandomInUnitSphere());
}

inline Vector3 RandomOnHemisphere(const Vector3& normal)
{
   Vector3 onUnitSphere = RandomUnitVector();
   // If in the same hemisphere as the normal
   if(Dot(onUnitSphere, normal) &gt 0.0)
   {
       return onUnitSphere;
   }
   return -onUnitSphere;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Using RandomOnHemisphere -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Using the RandomOnHemisphere</h2>

        <p>Pick a random bounce direction on the hemisphere aligned with the surface normal and recurse for indirect illumination.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Camera.cpp</p></div>
                <div class="Sconsole">
<pre><code>Color Camera::RayColor(const Ray& rRay, const Hittable& rWorld) const
{
   HitInfo hitInfo;
   if (rWorld.Hit(rRay, Interval(0, infinity), hitInfo)) {
      Vector3 direction = RandomOnHemisphere(hitInfo.normal);
      return 0.5 * RayColor(Ray(hitInfo.coordinates, direction), rWorld); // Recursion
   }
   
   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0.5, 0.7, 1.0);
}</code></pre>
                </div>
            </div>
        </div>

        <p>Result: grainy but convincing diffuse shading.</p>

        <figure>
            <img loading="lazy" src="../Images/RayTracing/DiffuseMatRender.webp" alt="Diffuse Material Render" style="width:40%; padding-bottom:5px" />
            <figcaption><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#diffusematerials/limitingthenumberofchildrays" target="_blank">img. Source</a></figcaption>
        </figure>
    </section>

    <!-- Section: Limit recursion -->
    <section>
        <h2 class="underline" style="text-decoration-color: cadetblue">Limiting recursion (max bounces)</h2>

        <p>Stop infinite recursion by passing a bouncesLeft counter that decrements at every bounce.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Camera.h</p></div>
                <div class="Sconsole">
<pre><code>class Camera
{
public:
   Camera() = default;
   Camera(double imageWidth, double ratio, int samplePerPixel = 10, int bounces = 10):  // here
   aspectRatio(ratio), width(imageWidth), sampleCount(samplePerPixel), maxBounces(bounces){}  // here too
   void Render(const Hittable& rWorld);

private:
   int height;
   double aspectRatio, width;
   int sampleCount;
   int maxBounces;  // Here
   Position center, originPixelLocation;
   Vector3 pixelDeltaX, pixelDeltaY;
  
   void Initialize();
   Color RayColor(const Ray& rRay, int bouncesLeft, const Hittable& rWorld) const;  // and here
   Ray GetRay(int x, int y) const;
   Vector3 PixelSampleSquared() const;
};</code></pre>
                </div>
            </div>
        </div>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Camera.cpp</p></div>
                <div class="Sconsole">
<pre><code>void Camera::Render(const Hittable& rWorld)
{
   ...
           for(int sample = 0; sample &lt sampleCount; sample ++)
           {
               Ray ray = GetRay(x, y);
               pixel += RayColor(ray, maxBounces, rWorld);
           }
          ...
}

...

Color Camera::RayColor(const Ray& rRay, int bouncesLeft, const Hittable& rWorld) const
{
   HitInfo hitInfo;
  
   if(bouncesLeft &lt= 0) return Color(0, 0, 0);
   if (rWorld.Hit(rRay, Interval(0, infinity), hitInfo)) {
       Vector3 direction = RandomOnHemisphere(hitInfo.normal);
       return 0.5 * RayColor(Ray(hitInfo.coordinates, direction), bouncesLeft-1, rWorld);
   }
   ...
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Example main -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Example: main with sampling & bounces</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Raytracing.cpp</p></div>
                <div class="Sconsole">
<pre><code>#include "Camera.h"
#include "HittableCollection.h"
#include "Sphere.h"

using namespace std;

int main(int argc, char* argv[])
{
   // World
   HittableCollection world;
   world.Add(make_shared&ltSphere>(Position(0, 0, -1), 0.5));
   world.Add(make_shared&ltSphere>(Position(0, -100.5, -1), 100));
  
   Camera camera(400, 16.0/9.0, 100, 50);
   camera.Render(world);

   return 0;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Fix for shadows -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Fix for self-shadowing (epsilon)</h2>

        <p>Use a small epsilon (e.g. 0.001) as the minimum ray time to avoid hitting the same surface due to numeric precision.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Camera.cpp</p></div>
                <div class="Sconsole">
<pre><code>Color Camera::RayColor(const Ray& rRay, int bouncesLeft, const Hittable& rWorld) const
{
   HitInfo hitInfo;
  
   if(bouncesLeft &lt= 0) return Color(0, 0, 0);
   if (rWorld.Hit(rRay, Interval(0.001, infinity), hitInfo)) {  // Hi
       Vector3 direction = RandomOnHemisphere(hitInfo.normal);
       return 0.5 * RayColor(Ray(hitInfo.coordinates, direction), bouncesLeft-1, rWorld);
   }
   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0.5, 0.7, 1.0);
}</code></pre>
                </div>
            </div>
        </div>

        <p>Brighter, more correct per-pixel lighting.</p>
    </section>

    <!-- Section: Lambertian -->
    <section>
        <h2 class="underline" style="text-decoration-color: cadetblue">True Lambertian reflection</h2>

        <p>Bias random scattering towards the normal by adding a random unit vector to the surface normal.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Camera.cpp</p></div>
                <div class="Sconsole">
<pre><code>Color Camera::RayColor(const Ray& rRay, int bouncesLeft, const Hittable& rWorld) const
{
   HitInfo hitInfo;
  
   if(bouncesLeft &lt= 0) return Color(0, 0, 0);
   if (rWorld.Hit(rRay, Interval(0.001, infinity), hitInfo)) {
      Vector3 direction = hitInfo.normal + RandomUnitVector();
      return 0.5 * RayColor(Ray(hitInfo.coordinates, direction), bouncesLeft-1, rWorld);
   }
   
   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0.5, 0.7, 1.0);
}</code></pre>
                </div>
            </div>
        </div>

        <figure>
            <img loading="lazy" src="../Images/RayTracing/point-of-intersection-of-the-dir.webp" alt="Point of intersection illustration" style="width:40%; padding-bottom:5px" />
            <figcaption><a href="https://www.math-only-math.com/important-properties-of-direct-common-tangents.html" target="_blank">img. Source</a></figcaption>
        </figure>

        <p>Produces stronger shadows and slightly bluer sky reflection.</p>
    </section>

    <!-- Section: Gamma correction -->
    <section>
        <h2 class="underline" style="text-decoration-color: cadetblue">Gamma Correction</h2>

        <p>Apply gamma correction (sqrt) before writing colors so output looks correct on displays.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Color.h</p></div>
                <div class="Sconsole">
<pre><code>inline double LinearToGamma(double linearComponent)
{
   return sqrt(linearComponent);
