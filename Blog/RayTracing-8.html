<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RayTracing 8</title>
    <link rel="icon" type="image/x-icon" href="../Images/Suprise.webp">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Loris Moreau">
    <meta name="description" content="Raytracing Blog">
    <meta name="keywords" content="Showcase, Loris, Moreau, Loris Moreau, Programmer, coding adventure, Blog, Post, Raytracing, C++, CPP, Raytracing in one weekend, Dielectrics, Refraction">

    <!-- Styles -->
    <link rel="stylesheet" href="../Styles/style.css">
    <link rel="stylesheet" href="../Styles/Code-Quote.css">

    <script src="../Scripts/Carousel.js" defer></script>
</head>

<body>
<!-- Main of the post -->
<main id="BlogPost" class="post">
    <!-- Top showcase: carousel + short intro in a flex row -->
    <header>
        <!-- ========== Section 1 Navbar ========== -->
        <nav style="margin: 0 auto 2em auto;">
            <ul>
                <li><a href="../Blog.html">Back</a></li>
                <li><a href="../index.html" target="_blank">Main</a></li>
                <li><a href="../Blog.html" target="_blank">Blog</a></li>
                <li><a href="../Resources.html" target="_blank">Resources</a></li>
            </ul>
        </nav>

        <!-- Carousel -->
        <div class="flex-container">
            <div class="showcase-carousel" role="region" aria-label="Showcase carousel">
                <button class="carousel-button prev" aria-label="Previous slide">&larr;</button>
                <div class="carousel-viewport">
                    <div class="carousel-track">
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/Refraction-Reflection.webp" alt="Refraction & Reflection">
                        </div>
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/Suprise.webp" alt="Surprise image">
                        </div>
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/JupiPipebomb.webp" alt="Showcase render">
                        </div>
                    </div>
                </div>
                <button class="carousel-button next" aria-label="Next slide">&rarr;</button>
                <div class="carousel-dots" aria-hidden="false"></div>
            </div>

            <!-- Intro / author column -->
            <div class="text-container">
                <h1>Dielectrics — RayTracing in one weekend (Part 8)</h1>
                <p>Dielectrics (glass, water, plastics) — implementing refraction, Schlick's approximation and hollow spheres.</p>
                <p><a target="_blank" href="https://github.com/Loris-Moreau/RayTracing" class="cta-button">GitHub Repository</a></p>
            </div>
        </div>
    </header>

    <!-- Intro / Overview -->
    <section>
        <h2 class="underline" style="text-decoration-color: dodgerblue">Part 8 — Dielectrics</h2>
        <h4>Fancy word for a type of glass / transparent material</h4>
        <p>Dielectric materials interact with light by reflecting and refracting — let's implement that in our ray tracer.</p>
        <figure>
            <img width="65%" loading="lazy" src="../Images/Refraction-Reflection.webp" alt="Refraction vs Reflection" />
            <figcaption><a href="https://en.wikipedia.org/wiki/Refraction" target="_blank">img. Source</a></figcaption>
        </figure>
    </section>

    <!-- Theory: Snell, vectors, dot product -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Refraction (Snell's Law)</h2>
        <p>Refraction is governed by Snell's law — refractive indices and angle between ray and surface normal determine the transmitted direction.</p>

        <p>
            <i>Useful values:</i> air = 1.0, glass ≈ 1.3–1.7, diamond = 2.40.
        </p>

        <h3 class="underline" style="text-decoration-color: cadetblue">Vector decomposition & dot product</h3>
        <p>To compute the refracted direction we split the outgoing ray into perpendicular and parallel components to the surface normal and use the relation derived from Snell's law.</p>
    </section>

    <!-- Code: reflect & refract helpers -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Implementing reflect & refract</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Vector3.h</p></div>
                <div class="Sconsole">
<pre><code>inline Vector3 Reflect(const Vector3& direction, const Vector3& normal)
{
   return direction - 2 * Dot(direction, normal) * normal;
}

inline Vector3 Refract(const Vector3& unitVector, const Vector3& normal, double refractionRatio)
{
   double cosTheta = fmin(Dot(-unitVector, normal), 1.0);
   Vector3 rayOutPerpendicular = refractionRatio * (unitVector + cosTheta * normal);
   Vector3 rayOutParallel = -sqrt(fabs(1.0 - rayOutPerpendicular.SquaredLength())) * normal;
   return rayOutPerpendicular + rayOutParallel;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Dielectric material -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Dielectric material</h2>
        <p>The dielectric will refract when possible, otherwise it will reflect. We'll also later add Schlick's approximation to mix reflection probabilistically.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Dielectric.h</p></div>
                <div class="Sconsole">
<pre><code>#pragma once

#include "Material.h"

class DielectricMaterial : public Material
{
private:
   double refractionIndex;

public:
   DielectricMaterial(double refIndex): refractionIndex(refIndex){}
   bool Scatter(const Ray& rRayIn, const HitInfo& hitInfo, Color& attenuation, Ray& scattered) const override;
};</code></pre>
                </div>
            </div>
        </div>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Dielectric.cpp</p></div>
                <div class="Sconsole">
<pre><code>#include "DielectricMaterial.h"
#include "Hittable.h"

bool DielectricMaterial::Scatter(const Ray& rRayIn, const HitInfo& hitInfo, Color& attenuation, Ray& scattered) const
{
   attenuation = Color(1.0, 1.0, 1.0);
   double refractionRatio = hitInfo.frontFace ? (1.0 / refractionIndex) : refractionIndex;
  
   Vector3 unitDirection = Unit(rRayIn.GetDirection());
   double cosTheta = fmin(Dot(-unitDirection, hitInfo.normal), 1.0);
   double sinTheta = sqrt(1.0 - cosTheta * cosTheta);

   bool cannotRefract = refractionRatio * sinTheta > 1.0;
   Vector3 direction;

   if(cannotRefract) direction = Reflect(unitDirection, hitInfo.normal);
   else direction = Refract(unitDirection, hitInfo.normal, refractionRatio);

   scattered = Ray(hitInfo.coordinates, direction);
   
   return true;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Scene integration -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Add dielectric to the scene</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Raytracing.cpp</p></div>
                <div class="Sconsole">
<pre><code>#include "Camera.h"
#include "DielectricMaterial.h"
#include "HittableCollection.h"
#include "LambertianMaterial.h"
#include "MetalMaterial.h"
#include "Sphere.h"

using namespace std;

int main(int argc, char* argv[])
{
   // World
   HittableCollection world;
   shared_ptr&ltMaterial> groundMat = make_shared&ltLambertianMaterial>(Color(0.8, 0.8, 0.0));
   shared_ptr&ltMaterial> leftMat = make_shared&ltDielectricMaterial>(1.5);
   shared_ptr&ltMaterial> centerMat = make_shared&ltLambertianMaterial>(Color(0.1, 0.2, 0.5));
   shared_ptr&ltMaterial> rightMat = make_shared&ltMetalMaterial>(Color(0.8, 0.6, 0.2), 0.0);
   
   world.Add(make_shared&ltSphere>(Position(0,-100.5,-1), 100, groundMat));
   world.Add(make_shared&ltSphere>(Position(0,0,-1), 0.5, centerMat));
   world.Add(make_shared&ltSphere>(Position(-1,0,-1), 0.5, leftMat));
   world.Add(make_shared&ltSphere>(Position(1, 0,-1), 0.5, rightMat));

  
   Camera camera(400, 16.0/9.0, 100, 50);
   camera.Render(world);
   
   return 0;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Schlick's approximation -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Schlick's Approximation</h2>
        <p>Reflectivity changes with angle — Schlick's approximation lets us probabilistically choose reflection vs refraction to simulate Fresnel effects.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Dielectric.h</p></div>
                <div class="Sconsole">
<pre><code>#pragma once

#include "Material.h"

class DielectricMaterial : public Material
{
private:
   double refractionIndex;
   static double Reflectance(double cosine, double pRefractionIndex);
public:
   DielectricMaterial(double refIndex): refractionIndex(refIndex){}
   bool Scatter(const Ray& rRayIn, const HitInfo& hitInfo, Color& attenuation, Ray& scattered) const override;
};</code></pre>
                </div>
            </div>
        </div>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Dielectric.cpp</p></div>
                <div class="Sconsole">
<pre><code>#include "DielectricMaterial.h"
#include "Hittable.h"

double DielectricMaterial::Reflectance(double cosine, double pRefractionIndex)
{
   // Schlick approximation of reflectance
   double reflectance = (1 - pRefractionIndex) / (1 + pRefractionIndex);
   reflectance *= reflectance;
   return reflectance + (1 - reflectance)*pow((1 - cosine), 5);
}

bool DielectricMaterial::Scatter(const Ray& rRayIn, const HitInfo& hitInfo, Color& attenuation, Ray& scattered) const
{
   attenuation = Color(1.0, 1.0, 1.0);
   double refractionRatio = hitInfo.frontFace ? (1.0 / refractionIndex) : refractionIndex;
  
   Vector3 unitDirection = Unit(rRayIn.GetDirection());
   double cosTheta = fmin(Dot(-unitDirection, hitInfo.normal), 1.0);
   double sinTheta = sqrt(1.0 - cosTheta * cosTheta);

   bool cannotRefract = refractionRatio * sinTheta > 1.0;
   Vector3 direction;

   if(cannotRefract || Reflectance(cosTheta, refractionRatio) &gt; RandomDouble()) direction = Reflect(unitDirection, hitInfo.normal);
   else direction = Refract(unitDirection, hitInfo.normal, refractionRatio);

   scattered = Ray(hitInfo.coordinates, direction);
   
   return true;
}</code></pre>
                </div>
            </div>
        </div>

        <p style="padding:0.5rem">Tip: create a hollow glass by adding a second sphere with a negative radius (same center).</p>
        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Raytracing.cpp (hollow)</p></div>
                <div class="Sconsole">
<pre><code>world.Add(make_shared&ltSphere>(Position(-1,0,-1), 0.5, leftMat));
world.Add(make_shared&ltSphere>(Position(-1,0,-1), -0.4, leftMat));  // Hollow</code></pre>
                </div>
            </div>
        </div>
    </section>

    <footer>
        <p style="color: var(--text-color-bright);">22-01-2024</p>
    </footer>
</main>

<!-- Navigation buttons -->
<div style="text-align:center; margin-top:1rem">
    <a href="RayTracing-7.html" class="cta-button">Previous</a>
    <a href="../Blog.html" class="cta-button secondary" style="margin:0 0.75rem">Entries</a>
    <a href="RayTracing-9.html" class="cta-button">Next</a>
</div>

</body>
</html>
