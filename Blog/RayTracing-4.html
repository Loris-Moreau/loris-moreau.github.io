<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>RayTracing 4</title>
    <link rel="icon" type="image/x-icon" href="../Images/Suprise.webp">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Loris Moreau">
    <meta name="description" content="Raytracing Blog">
    <meta name="keywords" content="Showcase, Loris, Moreau, Loris Moreau, Programmer, coding adventure, Blog, Post, Raytracing, C++, CPP, Raytracing in one weekend, Surface Normal Shading, Surface Normal, Shaders">

    <!-- Styles -->
    <link rel="stylesheet" href="../Styles/style.css">
    <link rel="stylesheet" href="../Styles/Code-Quote.css">

    <!-- Carousel script (deferred) -->
    <script src="../Scripts/Carousel.js" defer></script>
</head>

<body>
<!-- Main of the post -->
<main id="BlogPost" class="post">
    <!-- Top showcase: carousel + short intro in a flex row -->
    <header>
        <!-- ========== Section 1 Navbar ========== -->
        <nav style="margin: 0 auto 2em auto;">
            <ul>
                <li><a href="../Blog.html">Back</a></li>
                <li><a href="../index.html" target="_blank">Main</a></li>
                <li><a href="../Blog.html" target="_blank">Blog</a></li>
                <li><a href="../Resources.html" target="_blank">Resources</a></li>
            </ul>
        </nav>

        <!-- Carousel + intro -->
        <div class="flex-container">
            <div class="showcase-carousel" role="region" aria-label="Showcase carousel">
                <button class="carousel-button prev" aria-label="Previous slide">&larr;</button>
                <div class="carousel-viewport">
                    <div class="carousel-track">
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/RayTracing/SimpleRaytracing.webp" alt="Simple raytracing render">
                        </div>
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/RayTracing/SphereNormals.webp" alt="Sphere normals diagram">
                        </div>
                        <div class="carousel-slide">
                            <img loading="lazy" src="../Images/RayTracing/CircleIntersection.webp" alt="Intersection / discriminant diagram">
                        </div>
                    </div>
                </div>
                <button class="carousel-button next" aria-label="Next slide">&rarr;</button>
                <div class="carousel-dots" aria-hidden="false"></div>
            </div>

            <!-- Intro / author column -->
            <div class="text-container">
                <h1>Raytracing in one weekend in C++</h1>
                <p class="underline" style="text-decoration-color: royalblue">Part 4 — Surface Normal Shading</p>
                <p>
                    <a target="_blank" href="https://github.com/Loris-Moreau/RayTracing" class="cta-button">GitHub Repository</a>
                </p>
            </div>
        </div>
    </header>

    <!-- Section: Normals explanation -->
    <section>
        <h2 class="underline" style="text-decoration-color: dodgerblue">Surface Normal Shading</h2>

        <h2 class="underline" style="text-decoration-color: royalblue">Normals</h2>

        <p>The normal vector tells us which way a surface faces. For a sphere the outward normal at a hit point is the (hitPoint - center) vector normalized by the radius.</p>

        <figure>
            <img loading="lazy" src="../Images/RayTracing/SphereNormals.webp" alt="Sphere Normals" style="width:30%;" />
            <figcaption><a href="https://www.blenderplay.com/particle-system-emitter/tab-velocity/normal/" target="_blank">img. Source</a></figcaption>
        </figure>

        <p>To produce a normal map color we remap normalized normal components from [-1,1] to [0,1] then to RGB [0..255].</p>
    </section>

    <!-- Section: example code -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Normal-based shading (example)</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Raytracing.cpp</p></div>
                <div class="Sconsole">
<pre><code>double HitSphere(const Position& rCenter, double radius, const Ray& rRay)
{
   Vector3 oC = rRay.GetOrigin() - rCenter;
   double a = Dot(rRay.GetDirection(), rRay.GetDirection());
   double b = 2.0 * Dot(oC, rRay.GetDirection());
   double c = Dot(oC, oC) - radius * radius;

   double discriminant = b * b - 4 * a * c;
   if (discriminant &lt 0) return -1.0;

   return (-b - sqrt(discriminant)) / (2.0 * a);
}

Color RayColor(const Ray& rRay)
{
   double hitTime = HitSphere(Position(0, 0, -1), 0.5, rRay);
   if(hitTime &gt 0.0)
   { 
      Vector3 normal = Unit(rRay.At(hitTime) - Vector3(0, 0, -1));
      return 0.5 * Color(normal.x + 1.0, normal.y + 1.0, normal.z + 1.0);
   }

   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0, 0, 1.0);
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Simplify intersection -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Simplify the Ray–Sphere intersection</h2>

        <p>We can simplify the quadratic by using <code>halfB</code> (b = 2*halfB) and the squared-length identity for dot(v,v).</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Raytracing.cpp</p></div>
                <div class="Sconsole">
<pre><code>double HitSphere(const Position& rCenter, double radius, const Ray& rRay)
{
   Vector3 oC = rRay.GetOrigin() - rCenter;
   double a = rRay.GetDirection().SquaredLength();
   double halfB = Dot(oC, rRay.GetDirection());
   double c = oC.SquaredLength() - radius * radius;		

   double discriminant = halfB*halfB - a * c;

   if (discriminant &lt 0) return -1.0;
  
   return (-halfB - sqrt(discriminant)) / a;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Hittable abstraction -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Abstraction of Hittable Objects</h2>

        <p>Make an abstract <code>Hittable</code> interface so different geometry types implement their own <code>Hit</code> logic. Also pass a time/interval for valid <code>t</code> range.</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Hittable.h</p></div>
                <div class="Sconsole">
<pre><code>#pragma once

#include "Ray.h"

class HitInfo
{
public:
   Position coordinates;
   Vector3 normal;
   double time;
};

class Hittable
{
public:
   virtual ~Hittable() = default;
   virtual bool Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const = 0;
};</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Sphere class -->
    <section>
        <h2 class="underline" style="text-decoration-color: cadetblue">& the Sphere class</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Sphere.h</p></div>
                <div class="Sconsole">
<pre><code>#pragma once

#include "Hittable.h"

class Sphere: public Hittable
{
private:
   Position mCenter;
   double mRadius;

public:
   Sphere(Position center, double radius):mCenter(center), mRadius(radius){}
   bool Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const override;
  
};</code></pre>
                </div>
            </div>
        </div>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Sphere.cpp</p></div>
                <div class="Sconsole">
<pre><code>#include "Sphere.h"

bool Sphere::Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const
{
   Vector3 oC = rRay.GetOrigin() - mCenter;
   double a = rRay.GetDirection().SquaredLength();
   double halfB = Dot(oC, rRay.GetDirection());
   double c = oC.SquaredLength() - mRadius*mRadius;

   double discriminant = halfB * halfB - a * c;
   if (discriminant &lt 0) return false;
   double sqrtDiscriminant = sqrt(discriminant);

   // Find the nearest root within the min/max time frame
   double root = (-halfB - sqrtDiscriminant) / a;
   if (root &lt= rayTimeMin || rayTimeMax &lt= root) {
       root = (-halfB + sqrtDiscriminant) / a;
       if (root &lt= rayTimeMin || rayTimeMax &lt= root)
           return false;
   }

   hitInfo.time = root;
   hitInfo.coordinates = rRay.At(hitInfo.time);
   Vector3 outwardNormal = (hitInfo.coordinates - mCenter) / mRadius;
   hitInfo.SetFaceNormal(rRay, outwardNormal);

   return true;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: HitInfo face normal -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Direction of the normals</h2>

        <p>We must determine whether a hit is on the front face. Use the dot product between the ray direction and outward normal to decide. Add helper to HitInfo:</p>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Hittable.h</p></div>
                <div class="Sconsole">
<pre><code>class HitInfo
{
public:
   Position coordinates;
   Vector3 normal;
   double time;
   bool frontFace;

   void SetFaceNormal(const Ray& rRay, const Vector3& outwardNormal)
   {
       // NOTE: outwardNormal must be unit length
       frontFace = Dot(rRay.GetDirection(), outwardNormal) &lt 0;
       normal = frontFace ? outwardNormal : -outwardNormal;
   }
};</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: collection & utilities -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Hittable collection & utilities</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>HittableCollection.h</p></div>
                <div class="Sconsole">
<pre><code>#pragma once

#include "Hittable.h"
#include &ltmemory>
#include &ltvector>

class HittableCollection : public Hittable
{
private:
   std::vector&ltstd::shared_ptr&ltHittable>> mPool;

public:
   HittableCollection()=default;
   HittableCollection(std::shared_ptr&ltHittable> hittable) { Add(hittable); }

   void Clear() { mPool.clear(); }
   void Add(std::shared_ptr&ltHittable> hittable) { mPool.push_back(hittable); }

   bool Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const override;
};</code></pre>
                </div>
            </div>
        </div>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>HittableCollection.cpp</p></div>
                <div class="Sconsole">
<pre><code>#include "HittableCollection.h"

using namespace std;

bool HittableCollection::Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const
{
   HitInfo tempInfo;
   bool hasHit = false;
   auto closestHit = rayTimeMax;

   for (const shared_ptr&ltHittable>& hittable : mPool) {
       if (hittable->Hit(rRay, rayTimeMin, closestHit, tempInfo)) {
           hasHit = true;
           closestHit = tempInfo.time;
           hitInfo = tempInfo;
       }
   }

   return hasHit;
}</code></pre>
                </div>
            </div>
        </div>
    </section>

    <!-- Section: Interval & final RayColor usage -->
    <section>
        <h2 class="underline" style="text-decoration-color: royalblue">Intervals & final hookup</h2>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Interval.h</p></div>
                <div class="Sconsole">
<pre><code>class Interval
{
public:
   double min, max;
   Interval() : min(+infinity), max(-infinity){} // Default interval is empty
   Interval(double pMin, double pMax): min(pMin), max(pMax){}

   bool Contains(double x) const
   {
       return min &lt= x && x &lt= max;
   }

   bool Surrounds(double x) const
   {
       return min &lt x && x &lt max;
   }

   static const Interval Empty, Universe;
};

const static Interval Empty (+infinity, -infinity);
const static Interval Universe (-infinity, +infinity);</code></pre>
                </div>
            </div>
        </div>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title"><p>Raytracing.cpp</p></div>
                <div class="Sconsole">
<pre><code>Color RayColor(const Ray& rRay, const Hittable& rWorld)
{
   HitInfo hitInfo;
   if (rWorld.Hit(rRay, Interval(0, infinity), hitInfo)) {
       return 0.5 * (hitInfo.normal + Color(1,1,1));
   }
   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0.5, 0.7, 1.0);
}</code></pre>
                </div>
            </div>
        </div>

        <figure>
            <img loading="lazy" src="../Images/RayTracing/SimpleRaytracing.webp" alt="Simple Raytracing Render" style="width:40%;" />
            <figcaption><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#addingasphere" target="_blank">img. Source</a></figcaption>
        </figure>
    </section>

    <section>
        <h2 class="underline" style="text-decoration-color: cadetblue">Test it</h2>
        <p>Render and verify: you should see a ground sphere and a small sphere with normals shaded. If everything works, we'll continue with lighting and materials next.</p>
    </section>

    <footer>
        <p style="color: var(--text-color-bright);">18-01-2024</p>
    </footer>
</main>

<!-- Navigation buttons -->
<div style="text-align:center; margin-top:1rem">
    <a href="RayTracing-3.html" class="cta-button">Previous</a>
    <a href="../Blog.html" class="cta-button secondary" style="margin:0 0.75rem">Entries</a>
    <a href="RayTracing-5.html" class="cta-button">Next</a>
</div>

</body>
</html>
