<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Optimizing a Raytracer</title>
    <link rel="icon" type="image/x-icon" href="../Images/RayTracing/Cornell's%20Box%20(B2,%20P8).png">
    <link rel="stylesheet" href="../styles.css">
    
    <!-- Meta Tags for SEO -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Loris Moreau">
    <meta name="description" content="Raytracing Blog">
    <meta name="keywords" content="Showcase, Loris, Moreau, Loris Moreau, Programmer, coding adventure, Blog, Post, Raytracing, C++, CPP, Raytracing in one weekend, Optimization, optimized, optimizing, Compute, Compute Shader, multi threading, Hyper threading, SIMD, optimizing a raytracer, raytracer optimization, efficient raytracing, efficient raytracer, optimized raytracing, improving raytracer performance, performance">
</head>

<body>
<div class="background"></div>

<!-- Back Button -->
<div style="text-align: left; margin-top: 12px; margin-left: 5px;">
    <a href="../Blog.html">
        <button>
            Back
        </button>
    </a>
</div>


<!-- Blog Content -->
<div id="BlogPost" class="post">
    
    <h2 class="underline">Raytracing in one weekend in c++</h2>
    <h3><a href="https://github.com/Loris-Moreau/RayTracing/tree/Compute-Shader" target="_blank">GitHub Repository</a></h3>
    <h3>Here's the <a href="https://github.com/Loris-Moreau/RayTracing/blob/Compute-Shader/Performance.md" target="_blank">Performance Document</a> where the render times are logged.</h3>
    <h3>And here's the <a href="ResearchProjBibliography.html" target="_blank">Bibliography</a> for this Research Project.</h3>
    
    <p style="padding: 5px"></p>
    
    <!-- Content Header -->
    <div>
        <h2 class="underline" style="text-decoration-color: dodgerblue">Part 10</h2>
        <!-- <h4><i>This part is going to be hard, for all of us</i>.</h4> -->
        <h3>Currently doing a research project & the theme I've chosen for myself is "<i class="underline" style="text-decoration-color: green">Optimization</i>".</h3>
        <h3>
            After finishing the <a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html" target="_blank">1st book</a> I was kinda annoyed at the render time, 
            and as I went through the <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html" target="_blank">2nd book</a>  it only got worse 
            and the final render I did took 5 Hrs and was still quite noisy <i>(not good)</i>, 
            so today we will be looking into optimization techniques :
        </h3>
        
        <h3><a href="#SIMD">- SIMD</a> <i>(<a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data" target="_blank">explanation</a>)</i></h3>
        <h3><a href="#MultiThreading">- Multithreading</a> <i>(<a href="https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)" target="_blank">explanation</a>)</i></h3>
        <h3><a href="#Compute">- Compute Shaders</a> <i>(<a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank">explanation</a>)</i></h3>
        
        <p></p>
        
        <h4>All of these revolve around parallelizing the existing code <i>(it's annoying but doable)</i>.</h4>
        <h3>Each of these should shorten render times by quite a bit and allow us to use more samples & bounces.</h3>
        
        <p style="padding: 2px"></p>
        
        <h2 class="underline" style="text-decoration-color: dodgerblue">Optimization</h2>
        
        <h4><i>This code is the finished code of <a href="https://raytracing.github.io/books/RayTracingTheNextWeek.html" target="_blank">book 2</a></i></h4>
        <h4><i>Should look a little something like this : </i></h4>
        <img loading="lazy" src="../Images/RayTracing/Final%20Render%20high-Res%20(B2).png" alt="Final Render of Book 2" style="width: 55%; padding-bottom: 5px;" />
        <h5><a href="https://github.com/Loris-Moreau/RayTracing/blob/main/Images/Final%20Render%20high-Res%20(B2).png" target="_blank">img. Source</a></h5>
    </div>
    
    <p style="padding: 5px"></p>
    
    <!-- SIMD -->
    <h2 class="underline" style="text-decoration-color: royalblue; padding-bottom: 7px" id="SIMD">SIMD</h2>
    <div>
        <h4>"Single instruction, multiple data <i>(SIMD)</i> is a type of parallel processing in 
            <a href="https://en.wikipedia.org/wiki/Flynn%27s_taxonomy" target="_blank">Flynn's taxonomy</a>.</h4>
        <h4>SIMD describes computers with multiple processing elements that perform the same operation on multiple data points simultaneously.</h4>
        <h4>
            SIMD can be internal <i>(part of the hardware design)</i> and it can be directly accessible through an 
            <a href="https://en.wikipedia.org/wiki/Instruction_set_architecture" target="_blank">instruction set architecture</a> <i>(ISA)</i>, 
            but it should not be confused with an ISA."
        </h4>
        <h4><a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data" target="_blank">Source.</a></h4>
        
        <h4>SIMD is basically operations on arrays, like so :</h4>
        <img loading="lazy" src="../Images/RayTracing/SIMD-operation.png" alt="SISD vs SIMD Operations" style="width: 65%; padding-bottom: 5px;" />
        <h5><a href="https://blog.wasmer.io/webassembly-and-simd-13badb9bf1a8" target="_blank">img. Source</a></h5>
        <h4><a href="https://medium.com/@bromanz/simd-sse-unity3d-net-2-0-70f6c911713f" target="_blank">SIMD use in Unity3D</a></h4>
        
        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Things to Remember : </h2>
        <h3>- If you're using the correct memory layouts when implementing SIMD, the rest of the problems will solve themselves.</h3>
        <h3>- Parallel performance largely depends on the extent to which your program is parallelized.</h3>
        <h3>- Compiling code with the <b class="quote">-march=native</b> flag generates optimized code for your CPU.</h3>
    </div>
    <p style="padding: 4px"></p>
    <div>
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">How do we achieve this ?</h2>
        <h3>Since SIMD is not a computation problem, it's simply a memory layout problem.</h3>
        <h3>
            To make our sphere data "SIMD-friendly", we will use the 
            <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/memory-layout-transformations.html" target="_blank">Structure of Arrays (SoA)</a> 
            where each field is stored in its own array.
        </h3>
        <h3>
            SoA excels when you frequently access only a subset of a struct’s members, each cache line then holds just the data you need, 
            leading to significant gains in performance.
        </h3>
        <h3>
            However, since our ray-tracing functions always reference every Sphere field together, a pure SoA approach isn’t ideal.
        </h3>
        <h3>
            Instead, we use an 
            <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/memory-layout-transformations.html" target="_blank">Array of Structures of Arrays (AoSoA)</a> 
            layout. In AoSoA, each field is still an array, but its length matches the SIMD lane width <i>(<b class="quote">LANE_WIDTH</b>)</i>.
        </h3>
        <h3>
            If we have more spheres than fit in one SIMD vector, we simply add another “lane” <i>(another fixed-size chunk)</i> to our AoSoA array.
        </h3>
        <h3>
            This way, each chunk maps perfectly onto SIMD registers, maximizing both alignment and throughput.
        </h3>
        <h3>Here is a good <a href="https://www.youtube.com/watch?v=0_Byw9UMn9g" target="_blank">video</a> about this problem.</h3>

        <p style="padding: 4px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Amdahl's Law</h2>
        <h3>We are not gaining as much as we should from SIMD & SSE operations, but why ?</h3>
        <h3>
            <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank">Amdahl's Law</a> 
            states that the overall speedup from parallelization is limited by the portion of the program that must remain serial.
        </h3>
        <h3>In our case, 50% of execution time is spent in the Intersection function.</h3>
        <h3>As the chart below illustrates, no matter how many cores or SIMD lanes we employ, the maximum achievable speedup caps at 2x.</h3>
        <h3>This explains why using a 4-lane vector unit doesn't yield a 4x performance gain.</h3>
        
        <img loading="lazy" src="../Images/RayTracing/AmdahlsLaw.png" alt="Amdahl's Law" style="width: 65%; padding-bottom: 5px;" />
        <h5><a href="https://en.wikipedia.org/wiki/Amdahl%27s_law" target="_blank">img. Source</a></h5>
        
        <h3>And remember : "<i>Don't do anything you don't need to</i>".</h3>
        
        <p style="padding: 4px"></p>
        
        <h3>With SIMD we managed to cut render time in 2.</h3>
        
        <!-- Final Recorded Time -->
        <h2 style="padding-bottom: 5px">Final recorded Time :</h2>
        <h3 style="padding-bottom: 0"><b class="quote">case 10: FinalSceneB2(600, 200, 100, 20, 250) :</b></h3>
        <h3 style="padding-top: 0; padding-bottom: 0"><b class="quote">- Non-Optimized : 5 Hrs</b></h3>
        <h3  style="padding-top: 0; padding-bottom: 0"><b class="quote">- SIMD Optimized : 2 Hrs 18 Min</b></h3>
    </div>
    
    <p style="padding: 42px"></p>
    
    <!-- MultiThreading -->
    <h2 class="underline" style="text-decoration-color: royalblue; padding-bottom: 7px" id="MultiThreading">MultiThreading</h2>
    <div>
        <h4>"Multithreading is a form of parallelization or dividing up work for simultaneous processing.</h4>
        <h4>Instead of giving a large workload to a single core, threaded programs split the work into multiple software threads.</h4>
        <h4>These threads are processed in parallel by different CPU cores to save time."</h4>
        <h4><a href="https://www.intel.com/content/www/us/en/gaming/resources/hyper-threading.html#articleparagraph_cop" target="_blank">Source.</a></h4>
        
        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Things to Remember : </h2>
        <h3>
            As this <a href="https://fgiesen.wordpress.com/2013/01/31/cores-dont-like-to-share/" target="_blank">blog by rygorous</a> states :
        </h3>
        <h3>
            After writing shared data, other threads must throw all the work, 
            retrieve the latest value of the variable since the cached version is no longer valid, 
            and then restart their tasks. 
            This phenomenon is referred to as "<a href="https://en.wikipedia.org/wiki/False_sharing" target="_blank">false sharing</a>".
        </h3>
        <h3>Here is an interesting video talking about <a href="https://www.youtube.com/watch?v=WDIkqP4JbkE" target="_blank">Cpu Caches</a>.</h3>
    </div>
    <p style="padding: 2px"></p>
    <div>
        <img loading="lazy" src="../Images/RayTracing/40-years-processor-trend.png" alt="40 Years Processor Trend" style="width: 75%; padding-bottom: 5px;" />
        <h5><a href="https://www.karlrupp.net/2015/06/40-years-of-microprocessor-trend-data" target="_blank">img. Source</a></h5>
        <h4>If you're in computer science you've probably seen this image or a variation of it.</h4>
        <h3>
            This image shows us that, although transistor counts continue to climb in a somewhat linear fashion, 
            the era of ever-increasing single-threaded processor speeds is effectively over. 
        </h3>
        <h3>
            As a matter of fact, as the gains in single-core performance have tapered off, chip designers have responded by packing ever more logical cores onto each die.
        </h3>
        <h3>
            The takeaway is that if your application relies on a purely single-threaded workload, you’ll see diminishing returns on the latest CPUs. 
            To harness their full power, you must divide your work across multiple cores.
        </h3>
        
        <p style="padding: 10px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Breaking a Program into Parallel Tasks : </h2>
        <h3>
            To exploit multiple CPU threads, you first need to 
            <a href="https://softwareengineering.stackexchange.com/questions/82582/best-way-to-break-down-overwhelming-code-into-manageable-chunks" target="_blank">decompose your program</a> 
            into independent pieces, <i>a notoriously tricky challenge in general</i>. 
            Once you’ve done that, you then need to coordinate those pieces safely, 
            <i>which often introduces <a href="https://stackoverflow.com/a/2860263" target="_blank">overhead</a></i>. 
            Fortunately, ray-tracing is a textbook example of an 
            “<a href="https://en.wikipedia.org/wiki/Embarrassingly_parallel" target="_blank">embarrassingly parallel</a>” problem :
        </h3>
        <h3>- each pixel in the final image can be computed in isolation.</h3>
        
        <p></p>
        
        <h3>
            We are calculating each pixel. And almost every pixel is independent, so synchronization will be minimal. 
            The cores are going to render each pixel independently, and when all the pixels are done, we put it all together into the final image.
        </h3>
        
        <p style="padding: 15px"></p>
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Lock-Free Synchronization with Atomics</h2>
        <h3>
            I’ve been looking into <a href="https://learn.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming" target="_blank">lockless</a> programming techniques,
            <i>
                (<a href="https://preshing.com/20120612/an-introduction-to-lock-free-programming/" target="_blank">intro to lock free programming</a> &
                <a href="https://www.reddit.com/r/cpp/comments/vg4myt/is_lockfree_programming_is_always_better_than/" target="_blank">an interesting talk about Lock-free vs Mutex</a>)
            </i>, 
            & how compilers and CPUs <a href="https://en.wikipedia.org/wiki/Memory_ordering" target="_blank">reorder memory operations</a>, 
            the differences between various architectures, and so on.
        </h3>
        <h3>
            Much of what I’ve read uses the Windows API, but the underlying principles apply across platforms. 
        </h3>
        <h3>
            While traditional mutexes are often the easiest way to guard shared data, I plan to use atomic instructions instead, so threads never block one another, 
            since Lock-free programming is only for some rare use cases, typically with lots of threads meeting at the same variable.
        </h3>
        <h3>
            In the context of this ray-tracer project where synchronization needs are minimal I believe an atomic-based approach will be straightforward and more performant.
        </h3>
        
        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">So how do we divide work evenly to all threads ?</h2>
        <h3>The answer is simple : We divide the image into multiple parts/tasks.</h3>
        <h3>
            Threads pull the next available task from a shared queue as soon as they finish their current one.
            This way, if one thread encounters a lengthy job, all the others remain busy with other tasks.</h3>
        <h3>A good explanation for this problem <a href="https://developer.apple.com/videos/play/wwdc2017/706/?time=345" target="_blank">here</a>.</h3>
        <h3>
            We could spawn one thread per image row and leveraged 
            <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch" target="_blank">Apple’s Grand Central Dispatch</a> <i>(GCD)</i>.
            which lets you easily multi-thread your loop using the <b class="quote">dispatch_apply</b> function, 
            GCD automatically distributes iterations across all available threads and waits until they all complete, with no manual synchronization needed.
            This could work quite well & wouldn't be too hard to implement.
        </h3>
        <h3>
            Ultimately, though, we're going to use the simple work-queue approach from <a href="https://www.youtube.com/watch?v=ZAeU3Z0PmcU" target="_blank">Handmade Ray</a>. 
            We package units of work into <i>“orders”</i> and push them onto a queue. Each thread continuously fetches and executes orders, 
            if the queue is empty, the thread idles until new work appears.
        </h3>

        <h4>A little something like this :</h4>
        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>Work Queue</p>
                </div>
                <div class="Sconsole">
      <pre><code>struct WorkOrder 
{
    Image* image;
    World* world;
    uint32_t startRowIndex;
    uint32_t endRowIndex;
    uint32_t sampleSize;
    uint32_t* randomState;
};

struct WorkQueue 
{
    uint32_t workOrderCount;
    WorkOrder* workOrders;

    volatile uint64_t nextOrderToDo;
    volatile uint64_t finishedOrderCount;
    volatile uint64_t totalBouncesComputed;
};

bool RaytraceWork(WorkQueue* workQueue) 
{
    uint32_t nextOrderToDo = InterlockedAddAndReturnPrevious(&workQueue->nextOrderToDo, 1);
    if (nextOrderToDo >= workQueue->workOrderCount) 
    {
        return false;
    }
    
    fetch the next WorkOrder
    
    ...
    raytracing
    ...
    
    InterlockedAddAndReturnPrevious(&workQueue->totalBouncesComputed, totalBounces);
    InterlockedAddAndReturnPrevious(&workQueue->finishedOrderCount, 1);
    
    return true;
}</code></pre>
                </div>
            </div>
        </div>
        
        <p style="padding: 2px"></p>
        
        <h3>
            In the end we managed to boost render time by roughly 2.5x for renders using Multithreading. 
        </h3>
        <h3>
            But we did not speed up linearly after using the third and fourth thread, 
            meaning we don't gain as much as expected from 
            <a href="https://www.intel.com/content/www/us/en/gaming/resources/hyper-threading.html#articleparagraph_cop_77384912" target="_blank">Hyper-Threading</a>, 
            but honestly I'm not very experienced in hyper-threading outside of this project, so perhaps I will do another post on this.
        </h3>

        <p style="padding: 4px"></p>
        
        <!-- Final Recorded Time -->
        <h2 style="padding-bottom: 5px">Final recorded Time :</h2>
        <h3 style="padding-bottom: 0"><b class="quote">case 10: FinalSceneB2(600, 200, 100, 20, 250) :</b></h3>
        <h3 style="padding-top: 0; padding-bottom: 0"><b class="quote">- Non-Optimized : 5 Hrs</b></h3>
        <h3  style="padding-top: 0; padding-bottom: 0"><b class="quote">- Multithreading Optimized : 2 Hrs 9 Min</b></h3>
    </div>
    
    <p style="padding: 42px"></p>
    
    <!-- Compute Shader -->
    <h2 class="underline" style="text-decoration-color: royalblue; padding-bottom: 7px" id="Compute">Compute Shaders</h2>
    <div>
        <h4>
            "Like other programmable shaders <i>(vertex and geometry shaders for example)</i>, a compute shader is designed and implemented with 
            <a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl" target="_blank">HLSL</a> but that is just about where the similarity ends.
        </h4>
        <h4>A compute shader provides high-speed general purpose computing and takes advantage of the large numbers of parallel processors on the graphics processing unit (GPU).</h4>
        <h4>The compute shader provides memory sharing and thread synchronization features to allow more effective parallel programming methods."</h4>
        <h4><a href="https://learn.microsoft.com/en-us/windows/win32/direct3d11/direct3d-11-advanced-stages-compute-shader" target="_blank">Source.</a></h4>
        
        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px" id="ttrcs">Things to Remember : </h2>
        <h3>Base Raytracing code & Compute shader code aren't that far apart, so it's not too hard to transfer one to the other just annoying.</h3>
        <h3>
            One of the issues with GPU porting is that GLSL doesn't map memory into zeros. 
            You should be aware that it doesn't have a constructor that we use in C++ for filling struct memory with zeros
        </h3>
        <h3>
            <b>you should be aware of alignment</b> since one of the main causes for a black screen was
            <a href="https://learn.microsoft.com/en-us/cpp/cpp/alignment-cpp-declarations?view=msvc-170" target="_blank">alignment</a>, When using UBO or SSBO.
        </h3>
    </div>
    <p style="padding: 4px"></p>
    <div>
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">But How ?</h2>
        <h3>The point of this is to transfer the raytracer to the GPU, and since our code is already parallelized it shouldn't be much of a hassle to transfer it into GPU.</h3>
        <h3>
            The compute shader is going to do the same work that the CPU is doing. 
            Then it is going to produce the image as a texture object and send that texture into the fragment shader. 
        </h3>
        <h3>That fragment shader is then going to <a href="https://en.wikipedia.org/wiki/Gamma_correction" target="_blank">gamma correct</a> the image and render it to the screen.</h3>
        
        <p style="padding: 2px"></p>
        
        <h3>For this we're going to use <a href="https://www.khronos.org/opengl/wiki/Compute_Shader" target="_blank">OpenGL</a>, 
            since it is easier than something like <a href="https://vkguide.dev/docs/gpudriven/compute_shaders/" target="_blank">vulkan</a> and I had some experience with it before.
        </h3>
        <h3>OpenGL has compute shader support since version 4.3, so any newer version will work.</h3>
        <h3>I won't explain here how to do all the setup for OpenGL, but you can find what you need 
            <a href="https://learnopengl.com/book/book_pdf.pdf" target="_blank">here</a>.</h3>

        <p style="padding: 10px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Buffers</h2>
        <h3>When it comes to writing shaders, we’re in luck, 
            shader languages closely resemble C++, so you can often paste your ray-tracer code directly into a shader file. 
        </h3>
        <h3>The only differences are in data type names and some built-in function names, so beware of that, or you could make a macro to map them to the CPU versions.</h3>
        <h3>
            One challenge is how to supply scene data to the compute shader, 
            GLSL offers two main buffer types for this : 
        </h3>
        <h3>- <a href="https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object" target="_blank">Uniform Buffer Objects (UBOs)</a> for small, fast-access data</h3>
        <h3>- <a href="https://www.khronos.org/opengl/wiki/Shader_Storage_Buffer_Object" target="_blank">Shader Storage Buffer Objects (SSBOs)</a> for larger datasets.</h3>
        <h3>
            We're going to go with SSBOs because they allow variable-length arrays, this will let us pass scene elements without pre-defining a fixed size. 
            In practice, you should declare an SSBO in GLSL like this:
        </h3>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>SSBO</p>
                </div>
                <div class="Sconsole">
                    <pre><code>layout(shared, binding = 0) buffer MaterialBuffer {
    Material gMaterials[]; // Variable size array
};</code></pre>
                </div>
            </div>
        </div>

        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Alignment</h2>
        
        <h3>So that went well, but there is another problem <i>(I mentioned this <a href="#ttrcs">above</a>)</i>. The alignment of SSBO structs is not the same as C++ ones.</h3>
        <h3>According to the <a href="https://community.khronos.org/t/interpretation-of-std140-layout" target="_blank">OpenGL specification</a> : </h3>
        <h3>"(9) If the member is a structure, the base alignment of the structure is &ltN>, where &ltN> is the largest base alignment value of any of its members, ..."</h3>
        <h3>In our case, we have vec3 in our structs. Size of vec3 is 12 bytes but vec3 count as vec4. 
            So our alignment for structs should be 16. This can be done in many ways. You can put padding data into the structs.
        </h3>
        <h3>Or we can define offsets and tweak layout properties using 
            <a href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_enhanced_layouts.txt" target="_blank">enhanced layout extension</a>.</h3>
        
        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>Material</p>
                </div>
                <div class="Sconsole">
                    <pre><code>struct Material 
{
    // These two can be bundled as a vec4. First three component for color and the last one is for refractiveIndex;
    Vector3 color;
    float refractiveIndex;

    // These two as well
    Vector3 emitColor;
    float reflection; 
};</code></pre>
                </div>
            </div>
        </div>
        
        <h3>This can be done in <a href="https://www.khronos.org/opengl/wiki/Layout_Qualifier_%28GLSL%29" target="_blank">GLSL</a> like so :</h3>
        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>GLSL Material</p>
                </div>
                <div class="Sconsole">
                    <pre><code>struct Material 
{
    // In GLSL, all the vec3 type variables are aligned to 16 bytes (vec4). 
    // We can use extra float padding with the enhanced layout extension.
    // layout(component = 3) means w component of vec4 holds this value.
    vec3 color;
    layout(component = 3) float refractiveIndex;
    vec3 emitColor;
    layout(component = 3) float reflection; 
};</code></pre>
                </div>
            </div>
        </div>
        
        <h3>This work quite well with intel integrated GPUs, but the enhanced layout extension does not support compute shaders on Nvidia GPUs, so we can abandon the code above, 
            and now we need to <a href="https://learn.microsoft.com/en-us/cpp/cpp/align-cpp" target="_blank">align them in cpp</a>.</h3>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>Align Material in CPP</p>
                </div>
                <div class="Sconsole">
                    <pre><code>// Align these struct members to 16 byte.
__declspec(align(16)) struct Material {
    Vector3 color;
    float refractiveIndex;
    Vector3 emitColor;
    float reflection; 
};</code></pre>
                </div>
            </div>
        </div>
        
        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Checking for Errors</h2>
        <h3>When we write an OpeGL app we will often see thing we don't like <i>(e.g. black screen, white screen, crash, etc...)</i></h3>
        <h3>so we need to find these errors by creating our OpenGL context with 
            <a href="https://www.khronos.org/opengl/wiki/OpenGL_Error#Catching_errors_(the_easy_way)" target="_blank">debugging properties</a>.</h3>
        <h3>We can check for errors by calling 
            <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml" target="_blank">glGetError()</a> after each OpenGL function.</h3>
        <h3>
            We can register a debug callback function via 
            <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glDebugMessageCallback.xhtml" target="_blank">glDebugMessageCallback()</a>, 
            This lets OpenGL automatically report errors <i>(and other messages)</i> to your callback, eliminating the need for manual 
            <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glGetError.xhtml" target="_blank">glGetError()</a> checks everywhere.
        </h3>
        
        <p style="padding: 2px"></p>
        
        <h3>
            One of the big error we get is "Long Running Execution" or 
            <a href="https://docs.nvidia.com/gameworks/index.html#developertools/desktop/timeout_detection_recovery.htm" target="_blank">TDR</a>, 
            here is a <a href="https://youtu.be/VaGcs5-W6S4?si=6lnOD9yTl6ejm3Rn" target="_blank">video</a> talking about GPU crash debugging by Nvidia 
            as well as this <a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/display/timeout-detection-and-recovery" target="_blank">article</a> by microsoft 
            that talks about TDR and what steps to take to resolve it.
        </h3>
        <h3>
            Basically what TDR does is : 
            <a href="https://docs.nvidia.com/gameworks/index.html#developertools/desktop/timeout_detection_recovery.htm" target="_blank"> "If the operating system does not receive 
                a response from a graphics card within a certain amount of time <i>(default is 2 sec)</i>, the operating system resets the graphics card."
            </a>
            , so we just reduce the sample size, and it works again !!
        </h3>
        
        <p style="padding: 10px"></p>

        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Progressive Rendering</h2>
        <h3><a href="https://blog.cloudflare.com/parallel-streaming-of-progressive-images/#what-is-progressive-image-rendering" target="_blank">Progressive Rendering</a></h3>
        
        <h3>Most production raytracers work by first rendering a very low quality sampled image and then progressively refining it as more samples are accumulated.</h3>
        <h3>If you'd like to add that behavior : on each frame, you’ll blend in the newly rendered image with the running average to gradually improve quality.</h3>
        <h3>Something like this : </h3>

        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>Progressive Rendering</p>
                </div>
                <div class="Sconsole">
                    <pre><code>// First image.
layout(rgba32f, location = 0) readonly uniform image2D srcImage;
// Output image.
layout(rgba32f, location = 1) writeonly uniform image2D destImage;
...
// Number of frames averaged
layout(location = 4) uniform uint32_t frameIndex;

...

// Calculate the sum of all the previous samples
Vector3 sumColor = prevColor * frameIndex;
// Add new color to sum, then re-average it.
Vector3 finalColor = (color + sumColor) / (frameIndex + 1);</code></pre>
                </div>
            </div>
        </div>
        
        <p style="padding: 5px"></p>
        
        <h2 class="underline" style="text-decoration-color: cadetblue; padding-bottom: 10px">Performance</h2>
        <h3>OpenGL supports <a href="https://www.khronos.org/opengl/wiki/Atomic_Counter" target="_blank">Atomic Counters</a>, 
            so we're could count the rays bounces, or we could use SSBO again for the counter, then use 
            <a href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/atomicAdd.xhtml" target="_blank">naive atomic add operation</a>,
            after the compute shader finished its job, you map the bounce count SSBO for reading the bounce count.</h3>
        <h3>Both of these have roughly the same performance, so you can use either, We will use the second method, like so :</h3>
        <div class="snippet">
            <div class="Swindow">
                <div class="Swindow-title">
                    <p>Atomic Operations</p>
                </div>
                <div class="Sconsole">
                    <pre><code>layout(binding = 3) buffer Counter { 
    uint32_t gBounceCount; 
};
...
atomicAdd(gBounceCount, totalBounces);

// C++ code
glBindBuffer(GL_SHADER_STORAGE_BUFFER, bounceCountSSBO);
uint32_t* counter = (uint32_t*) glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY);
bounceCount = counter[0];
glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);</code></pre>
                </div>
            </div>
        </div>
        
        <h3>and now we just run our code and hope for the best.</h3>
        
        <p style="padding: 4px"></p>
        
        <h3>With Compute Shaders it's almost 10x faster, <i>(and this is simply porting the original raytracer code into compute shaders we haven't actually optimized anything)</i>.</h3>
        
        <!-- Final Recorded Time -->
        <h2 style="padding-bottom: 5px">Final recorded Time :</h2>
        <h3 style="padding-bottom: 0"><b class="quote">case 10: FinalSceneB2(600, 200, 100, 20, 250) :</b></h3>
        <h3 style="padding-top: 0; padding-bottom: 0"><b class="quote">- Non-Optimized : 5 Hrs</b></h3>
        <h3  style="padding-top: 0; padding-bottom: 0"><b class="quote">- Compute Shader Optimized : 30 sec</b></h3>
        <p style="padding: 1px"></p>
        <h5>Damn I knew it was going to be way faster but this is WAY faster</h5>
    </div>
    
    
    <p style="padding: 25px"></p>
    
    <h3><a href="ResearchProjBibliography.html" target="_blank">Bibliography</a></h3>
    
    <p style="padding: 42px"></p>
    
    <h3>Next up we will take about VFXs</h3>
    
    <h3>Buh bye</h3>
    <p style="padding: 5px"></p>
</div>

<!-- Buttons -->
<div style="text-align: center; margin-top: 10px;">
    <!-- Previous Button, if none: href="../Blog.html" -->
    <a href="RayTracing-9.html">
        <button>
            Previous
        </button>
    </a>
    <!-- Back to blog -->
    <a href="../Blog.html">
        <button>
            Entries
        </button>
    </a>
    <!-- Next button, if none: href="../Blog.html" -->
    <a href=VFX-1.html>
        <button>
            Next
        </button>
    </a>
    <p style="padding: 7px"></p>
</div>

<!-- Date -->
<h5>07-05-2025</h5>
<p style="padding: 7px"></p>

<!-- Socials -->
<div>
    <ul class="example-2">
        <li class="icon-content">
            <a href="https://linkedin.com/in/loris-moreau" aria-label="LinkedIn" data-social="linkedin" target="_blank">
                <div class="filled"></div>
                <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        fill="currentColor"
                        class="bi bi-linkedin"
                        viewBox="0 0 16 16"
                        xml:space="preserve"
                >
                <path
                        d="M0 1.146C0 .513.526 0 1.175 0h13.65C15.474 0 16 .513 16 1.146v13.708c0 .633-.526 1.146-1.175 1.146H1.175C.526 16 0 15.487 0 14.854zm4.943 12.248V6.169H2.542v7.225zm-1.2-8.212c.837 0 1.358-.554 1.358-1.248-.015-.709-.52-1.248-1.342-1.248S2.4 3.226 2.4 3.934c0 .694.521 1.248 1.327 1.248zm4.908 8.212V9.359c0-.216.016-.432.08-.586.173-.431.568-.878 1.232-.878.869 0 1.216.662 1.216 1.634v3.865h2.401V9.25c0-2.22-1.184-3.252-2.764-3.252-1.274 0-1.845.7-2.165 1.193v.025h-.016l.016-.025V6.169h-2.4c.03.678 0 7.225 0 7.225z"
                        fill="currentColor"
                ></path>
            </svg>
            </a>
            <div class="tooltip">LinkedIn</div>
        </li>
        <li class="icon-content">
            <a href="https://github.com/Loris-Moreau" aria-label="GitHub" data-social="github" target="_blank">
                <div class="filled"></div>
                <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        fill="currentColor"
                        class="bi bi-github"
                        viewBox="0 0 16 16"
                        xml:space="preserve"
                >
                <path
                        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8"
                        fill="currentColor"
                ></path>
            </svg>
            </a>
            <div class="tooltip">GitHub</div>
        </li>
        <li class="icon-content">
            <a href="https://www.youtube.com/channel/UCRfo2k8XLOiRMOcuQEtNz5g" aria-label="Youtube" data-social="youtube" target="_blank">
                <div class="filled"></div>
                <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        fill="currentColor"
                        class="bi bi-youtube"
                        viewBox="0 0 16 16"
                        xml:space="preserve"
                >
                <path
                        d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01 0 0 1 1.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.01 2.01 0 0 1-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309 0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.01 2.01 0 0 1-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82l-.008-.104A31 31 0 0 1 0 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.01 2.01 0 0 1 1.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A100 100 0 0 1 7.858 2zM6.4 5.209v4.818l4.157-2.408z"
                        fill="currentColor"
                ></path>
            </svg>
            </a>
            <div class="tooltip">Youtube</div>
        </li>
    </ul>
</div>

<p style="padding: 2px"></p>

</body>
</html>
