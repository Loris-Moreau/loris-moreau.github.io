<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RayTracing 4</title>
    <link rel="icon" type="image/x-icon" href="../Images/Suprise.webp">
    <link rel="stylesheet" href="../Styles/MainStyle.css">
    
    <script src="../Scripts/CommonLayout.js" defer></script>
    
    <!-- Meta Tags for SEO -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Loris Moreau">
    <meta name="description" content="Raytracing Blog">
    <meta name="keywords" content="Showcase, Loris, Moreau, Loris Moreau, Programmer, coding adventure, Blog, Post, Raytracing, C++, CPP, Raytracing in one weekend, Surface Normal Shading, Surface Normal, Shaders">
</head>

<body>

<!-- Back Button -->
<div class="backButton">
    <a href="../Blog.html">
        <button>
            Back
        </button>
    </a>
</div>


<!-- Blog Content -->
<div id="BlogPost" class="post">

<h2 class="underline">Raytracing in one weekend in C++</h2>
<h4><a href="https://github.com/Loris-Moreau/RayTracing" target="_blank">
    GitHub Repository
</a></h4>
    <h3 class="underline" style="text-decoration-color: royalblue"> Part 4 </h3>
    
    <h2 class="underline" style="text-decoration-color: dodgerblue">Surface Normal Shading</h2>

    <p style="padding: 0"></p>
    
    <h2 class="underline" style="text-decoration-color: royalblue">Normals</h2>
    
    <h3>The normal vector allows us to know the direction that a surface is facing.</h3>
    <h3>We can make the normal unit length by dividing it by the sphere radius.</h3>
    <h3>For a sphere, the direction of the <strong class="underline" style="text-decoration-color: cadetblue">outward</strong> 
        normal is the direction of the hit point minus the center</h3>
    <img loading="lazy" src="../Images/RayTracing/SphereNormals.webp" alt="Sphere Normals" style="padding-bottom: 5px; width: 30%;" />
    <h5 style="padding-bottom: 25px"><a href="https://www.blenderplay.com/particle-system-emitter/tab-velocity/normal/" target="_blank">img. Source</a></h5>
    
    <h3><i>Normal Map :</i> We use the normal vector <strong class="underline" style="text-decoration-color: cadetblue">n</strong> 
        normalized ([ -1 ; 1]) and we translate it to a rgb value ([0;255],[0;255],[0;255])</h3>
    
    <h3>In code it looks a little something like :</h3>
    
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Raytracing.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>double HitSphere(const Position& rCenter, double radius, const Ray& rRay)
{
   Vector3 oC = rRay.GetOrigin() - rCenter;
   double a = Dot(rRay.GetDirection(), rRay.GetDirection());
   double b = 2.0 * Dot(oC, rRay.GetDirection());
   double c = Dot(oC, oC) - radius * radius;

   double discriminant = b * b - 4 * a * c;
   if (discriminant < 0) return -1.0;

   return (-b - sqrt(discriminant)) / (2.0 * a);

}

Color RayColor(const Ray& rRay)
{
   double hitTime = HitSphere(Position(0, 0, -1), 0.5, rRay);
   if(hitTime > 0.0)
   { 
      Vector3 normal = Unit(rRay.At(hitTime) - Vector3(0, 0, -1));
      return 0.5 * Color(normal.x + 1.0, normal.y + 1.0, normal.z + 1.0);
   }

   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0, 0, 1.0);

}</code></pre>
            </div>
        </div>
    </div>
    
    <h2 class="underline" style="text-decoration-color: royalblue">Simplify the Ray-sphere intersection</h2>

    <h3> <!-- Quadratic Equation -->
        <math display="block">
            <mrow>
                <mfrac>
                    <mrow>
                        <mrow>
                            <mo>−</mo>
                            <mi>b</mi>
                        </mrow>
                        <mo>±</mo>
                        <msqrt>
                            <mrow>
                                <msup>
                                    <mi>b</mi>
                                    <mn>2</mn>
                                </msup>
                                <mo>−</mo>
                                <mrow>
                                    <mn>4</mn>
                                    <mo>⁢</mo>
                                    <mi>a</mi>
                                    <mo>⁢</mo>
                                    <mi>c</mi>
                                </mrow>
                            </mrow>
                        </msqrt>
                    </mrow>
                    <mrow>
                        <mn>2</mn>
                        <mo>⁢</mo>
                        <mi>a</mi>
                    </mrow>
                </mfrac>
            </mrow>
        </math>
    </h3>
    
    <h3>We can simplify our discriminant calculation by assuming that : <i>b = 2h</i></h3>
    
    <h3> <!-- Quadratic Equation Simplified 1-->
        <math display="block">
            <mrow>
                <mfrac>
                    <mrow>
                        <mrow>
                            <mo>−</mo>
                            <mi>2h</mi>
                        </mrow>
                        <mo>±</mo>
                        <msqrt>
                            <mrow>
                                <msup>
                                    <menclose>
                                    <mi>(</mi>
                                    <mi>2h</mi>
                                    <mo>)</mo>
                                    </menclose>
                                    <mn>2</mn>
                                </msup>
                                <mo>−</mo>
                                <mrow>
                                    <mn>4</mn>
                                    <mo>⁢</mo>
                                    <mi>a</mi>
                                    <mo>⁢</mo>
                                    <mi>c</mi>
                                </mrow>
                            </mrow>
                        </msqrt>
                    </mrow>
                    <mrow>
                        <mn>2</mn>
                        <mo>⁢</mo>
                        <mi>a</mi>
                    </mrow>
                </mfrac>
            </mrow>
        </math>
    </h3>

    <h3>This allows us to get rid of the scalar multiplications.</h3>
    
    <h3> <!-- Quadratic Equation Simplified 2-->
        <math display="block">
            <mrow>
                <mfrac>
                    <mrow>
                        <mrow>
                            <mo>−</mo>
                            <mi>h</mi>
                        </mrow>
                        <mo>±</mo>
                        <msqrt>
                            <mrow>
                                <msup>
                                    <mi>h</mi>
                                    <mn>2</mn>
                                </msup>
                                <mo>−</mo>
                                <mrow>
                                    <mi>a</mi>
                                    <mo>⁢</mo>
                                    <mi>c</mi>
                                </mrow>
                            </mrow>
                        </msqrt>
                    </mrow>
                    <mrow>
                        <mi>a</mi>
                    </mrow>
                </mfrac>
            </mrow>
        </math>
    </h3>
    
    <p style="padding: 5px"></p>
    
    <h3>In code : </h3>
    <h3>We also add that a vector dotted by itself is equal to it's squared length </h3>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Raytracing.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>double HitSphere(const Position& rCenter, double radius, const Ray& rRay)
{
   Vector3 oC = rRay.GetOrigin() - rCenter;
   double a = rRay.GetDirection().SquaredLength();
   double halfB = Dot(oC, rRay.GetDirection());
   double c = oC.SquaredLength() - radius * radius;		

   double discriminant = halfB*halfB - a * c;

   if (discriminant &lt 0) return -1.0;
  
   return (-halfB - sqrt(discriminant)) / a;
}</code></pre>
            </div>
        </div>
    </div>
    
    <p style="padding: 5px"></p>

    <h2 class="underline" style="text-decoration-color: royalblue">Abstraction of Hittable Objects</h2>

    <h3>We want to be able to hit more than one objects.</h3>
    <h3>To do that, we will create a new class Hittable to describe anything that can be hit by a ray.</h3>
    <h3>This class will be abstract because each kind of object has to define what being Hit means to them.</h3>
    <h3>We will also add a <i class="underline" style="text-decoration-color: cadetblue">timeframe</i> 
        within which the ray is "valid" <i>(<strong style="color: limegreen">t</strong> has to be between a min and max value)</i>.</h3>


    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Hittable.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>#pragma once

#include "Ray.h"

class HitInfo
{
public:
   Position coordinates;
   Vector3 normal;
   double time;
};

class Hittable
{
public:
   virtual ~Hittable() = default;
   virtual bool Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const = 0;
};</code></pre>
            </div>
        </div>
    </div>
    
    <h2>& The sphere class <i>(Child of Hittable class)</i></h2>
    
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Sphere.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>#pragma once

#include "Hittable.h"

class Sphere: public Hittable
{
private:
   Position mCenter;
   double mRadius;

public:
   Sphere(Position center, double radius):mCenter(center), mRadius(radius){}
   bool Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const override;
  
};</code></pre>
            </div>
        </div>
    </div>
    
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Sphere.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>#include "Sphere.h"

bool Sphere::Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const
{
   Vector3 oC = rRay.GetOrigin() - mCenter;
   double a = rRay.GetDirection().SquaredLength();
   double halfB = Dot(oC, rRay.GetDirection());
   double c = oC.SquaredLength() - mRadius*mRadius;

   double discriminant = halfB * halfB - a * c;
   if (discriminant &lt 0) return false;
   double sqrtDiscriminant = sqrt(discriminant);

   // Find the nearest root withing the min max time frame
   double root = (-halfB - sqrtDiscriminant) / a;
   if (root &lt= rayTimeMin || rayTimeMax &lt= root) {
       root = (-halfB + sqrtDiscriminant) / a;
       if (root &lt= rayTimeMin || rayTimeMax &lt= root)
           return false;
   }

   hitInfo.time = root;
   hitInfo.coordinates = rRay.At(hitInfo.time);
   Vector3 outwardNormal = (hitInfo.coordinates - mCenter) / mRadius;
   hitInfo.SetFaceNormal(rRay, outwardNormal);

   return true;
}</code></pre>
            </div>
        </div>
    </div>
    
    <p style="padding: 2px"></p>
    
    <h2 class="underline" style="text-decoration-color: royalblue">Direction of the normals</h2>
    
    <h3>We have to determine which side of a geometric face we are hitting.</h3>
    <h3>What is interesting to us here is the outward normal. 
        And we can determine if we hit a front face by using the dot product between the ray cast and the normal.</h3>
    
    <h2 style="padding-bottom: 5px">Let's add some info to HitInfo</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Hittable.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>class HitInfo
{
public:
   Position coordinates;
   Vector3 normal;
   double time;
   bool frontFace;

   void SetFaceNormal(const Ray& rRay, const Vector3& outwardNormal)
   {
       //NOTE : The outwardNormal vector should be unit length
       frontFace = Dot(rRay.GetDirection(), outwardNormal) &lt 0;
       normal = frontFace ? outwardNormal : -outwardNormal;
   }
};</code></pre>
            </div>
        </div>
    </div>
    
    <h2 style="padding-bottom: 5px">Let finish the Sphere Hit Function</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Sphere.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>hitInfo.time = root;
hitInfo.coordinates = rRay.At(root);
Vector3 outwardNormal = (hitInfo.coordinates - mCenter) / mRadius;
hitInfo.SetFaceNormal(rRay, outwardNormal);
          
return true;</code></pre>
            </div>
        </div>
    </div>
    
    <p style="padding: 2px"></p>

    <h2 class="underline" style="text-decoration-color: royalblue">Make a list of Hittable Objects</h2>
    
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>HittableCollection.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>#pragma once

#include "Hittable.h"
#include &ltmemory>
#include &ltvector>

class HittableCollection : public Hittable
{
private:
   std::vector&ltstd::shared_ptr&ltHittable>> mPool;

public:
   HittableCollection()=default;
   HittableCollection(std::shared_ptr&ltHittable> hittable) { Add(hittable); }

   void Clear() { mPool.clear(); }
   void Add(std::shared_ptr&ltHittable> hittable) { mPool.push_back(hittable); }

   bool Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const override;
};</code></pre>
            </div>
        </div>
    </div>
    
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>HittableCollection.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>#include "HittableCollection.h"

using namespace std;

bool HittableCollection::Hit(const Ray& rRay, double rayTimeMin, double rayTimeMax, HitInfo& hitInfo) const
{
   HitInfo tempInfo;
   bool hasHit = false;
   auto closestHit = rayTimeMax;

   for (const shared_ptr&ltHittable>& hittable : mPool) {
       if (hittable->Hit(rRay, rayTimeMin, closestHit, tempInfo)) {
           hasHit = true;
           closestHit = tempInfo.time;
           hitInfo = tempInfo;
       }
   }

   return hasHit;
}</code></pre>
            </div>
        </div>
    </div>

    <p style="padding: 2px"></p>
    
    <h2  style="padding-bottom: 5px">Simple Utility File</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Utility.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>#pragma once

#include &ltcmath>
#include &ltlimits>
#include &ltmemory>
#include "Ray.h"

using std::shared_ptr;
using std::make_shared;
using std::sqrt;

const double infinity = std::numeric_limits&ltdouble>::infinity();
const double pi = 3,141592653589793238462643383279502884197169; // hehe

inline double DegToRad(double degrees)
{
   return degrees * pi / 180.0;
}</code></pre>
            </div>
        </div>
    </div>


    <p style="padding: 2px"></p>
    
    <h2  style="padding-bottom: 5px">Fix up the Main</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Raytracing.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>// Remove HitSphere function

Color RayColor(const Ray& rRay, const Hittable& rWorld)
{
   HitInfo hitInfo;
   if (rWorld.Hit(rRay, 0, infinity, hitInfo)) {
       return 0.5 * (hitInfo.normal + Color(1,1,1));
   }
   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0.5, 0.7, 1.0);
}</code></pre>
            </div>
        </div>
    </div>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Raytracing.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>//Position of the top left pixel
Vector3 viewportOrigin = cameraCenter - Vector3(0, 0, focalLength) 
                       - viewportX / 2 - viewportY / 2;

Vector3 originPixelLocation = viewportOrigin + 0.5 * (pixelDeltaX + pixelDeltaY);

//World
HittableCollection world;
world.Add(make_shared&ltSphere>(Position(0,0,-1), 0.5));
world.Add(make_shared&ltSphere>(Position(0,-100.5,0), 100));

//Image
cout &lt&lt "P3\n" &lt&lt width &lt&lt ' ' &lt&lt height &lt&lt "\n255\n";</code></pre>
            </div>
        </div>
    </div>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Raytracing.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>for(int y = 0; y &lt height; y ++)
{
   clog &lt&lt "Progress : " &lt&lt (y*100/height) &lt&lt " %\n" &lt&lt flush;
   for (int x = 0; x &lt width; x ++)
   {
       Position pixelCenter = originPixelLocation + (x * pixelDeltaX) + (y * pixelDeltaY);
       Vector3 direction = pixelCenter - cameraCenter;
       Ray ray(cameraCenter, direction);
       Color pixel = RayColor(ray, world);
       WriteColor(cout, pixel);
   }
}</code></pre>
            </div>
        </div>
    </div>
    
    <h3>Alright now render, and it should look like this : </h3>
    <img loading="lazy" src="../Images/RayTracing/SimpleRaytracing.webp" alt="Simple Raytracing Render" style="padding-bottom: 5px; width: 40%"/>
    <h5 style="padding-bottom: 25px"><a href="https://raytracing.github.io/books/RayTracingInOneWeekend.html#addingasphere" target="_blank">img. Source</a></h5>
    
    <p style="padding: 7px"></p>
    
    <h2 class="underline" style="text-decoration-color: royalblue">Intervals</h2>
    
    <h3>We will now implement an interval system.</h3>
    <h3>This is a simple way to describe min and max time frame where the ray is valid and the bounce can be taken into account !</h3>


    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Interval.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>class Interval
{
public:
   double min, max;
   Interval() : min(+infinity), max(-infinity){} // Default interval is empty
   Interval(double pMin, double pMax): min(pMin), max(pMax){}

   bool Contains(double x) const
   {
       return min <= x && x <= max;
   }

   bool Surrounds(double x) const
   {
       return min < x && x < max;
   }

   static const Interval Empty, Universe;
};

const static Interval Empty (+infinity, -infinity);
const static Interval Universe (-infinity, +infinity);
</code></pre>
            </div>
        </div>
    </div>


    
    <h2 style="padding-bottom: 5px">In Headers</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Hittable.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>virtual bool Hit(const Ray& rRay, Interval rayTime, HitInfo& hitInfo) const = 0;
</code></pre>
            </div>
        </div>
    </div>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>HittableCollection.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>bool Hit(const Ray& rRay, Interval rayTime, HitInfo& hitInfo) const override;
</code></pre>
            </div>
        </div>
    </div>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Sphere.h</p>
            </div>
            <div class="Sconsole">
      <pre><code>bool Hit(const Ray& rRay, Interval rayTime, HitInfo& hitInfo) const override;
</code></pre>
            </div>
        </div>
    </div>
    
    <h2 style="padding-bottom: 5px">In cpp</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>HittableCollection.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>bool HittableCollection::Hit(const Ray& rRay, Interval rayTime, HitInfo& hitInfo) const
{
   HitInfo tempInfo;
   bool hasHit = false;
   auto closestHit = rayTime.max;

   for (const shared_ptr&ltHittable>& hittable : mPool) {
       if (hittable->Hit(rRay, Interval(rayTime.min , closestHit), tempInfo)) {
           hasHit = true;
           closestHit = tempInfo.time;
           hitInfo = tempInfo;
       }
   }

   return hasHit;
}
</code></pre>
            </div>
        </div>
    </div>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Sphere.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>bool Sphere::Hit(const Ray& rRay, Interval rayTime, HitInfo& hitInfo) const
{
   	...

   // Find the nearest root withing the min max time frame
   double root = (-halfB - sqrtDiscriminant) / a;
   if (!rayTime.Surrounds(root)) {
       root = (-halfB + sqrtDiscriminant) / a;
       if (!rayTime.Surrounds(root))
           return false;
   }

...
</code></pre>
            </div>
        </div>
    </div>
    
    <h2 style="padding-bottom: 5px">And finally in the main</h2>
    <!-- Code Snippet -->
    <div class="snippet">
        <div class="Swindow">
            <div class="Swindow-title">
                <p>Raytracing.cpp</p>
            </div>
            <div class="Sconsole">
      <pre><code>Color RayColor(const Ray& rRay, const Hittable& rWorld)
{
   HitInfo hitInfo;
   if (rWorld.Hit(rRay, Interval(0, infinity), hitInfo)) {
       return 0.5 * (hitInfo.normal + Color(1,1,1));
   }
   Vector3 unitDirection = Unit(rRay.GetDirection());
   double blue = 0.5 * (unitDirection.y + 1.0);
   return (1.0 - blue) * Color(1.0, 1.0, 1.0) + blue * Color (0.5, 0.7, 1.0);
}
</code></pre>
            </div>
        </div>
    </div>
    
    <p style="padding: 1px"></p>
    
    <h2>Test it to make sure it works</h2>
    <h3>& I'll see you in the next one</h3>
    <h3>buh bye</h3>
    <p style="padding: 5px"></p>
</div>

<!-- Buttons -->
<div style="text-align: center; margin-top: 10px;">
    <!-- Previous Button, if none: href="../Blog.html" -->
    <a href="RayTracing-3.html">
        <button>
            Previous
        </button>
    </a>
    <!-- Back to blog -->
    <a href="../Blog.html">
        <button>
            Entries
        </button>
    </a>
    <!-- Next button, if none: go back to first post currently: href="Workflow.html"" -->
    <a href="RayTracing-5.html">
        <button>
            Next
        </button>
    </a>
    <p style="padding: 7px"></p>
</div>

<!-- Date -->
<h5>18-01-2024</h5>

</body>
</html>
